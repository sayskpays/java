
-- DQL

SELECT * FROM HR.JOBS;

-- DML 

INSERT INTO HR.JOBS VALUES('TEST','test',30000,50000);

UPDATE HR.JOBS SET JOB_ID='AD_JUN' WHERE JOB_ID='AD_HONG';

DELETE FROM HR.JOBS WHERE JOB_ID='AD_HONG';

-- DDL

CREATE TABLE DEPT (DEPTNO NUMBER(4),DNAME VARCHAR2(20),LOC VARCHAR2(20));

ALTER TABLE DEPT MODIFY (DNAME VARCHAR2(30));

ALTER TABLE DEPT RENAME TO DEPT_01;

TRUNCATE TABLE DEPT_01;

DROP TABLE DEPT_01;

-- TCL

COMMIT;
ROLLBACK;
SAVEPOINT;

-- 데이터베이스 가동 중 인지 확인
SELECT status FROM V$instance;

-- 데이터베이스 가동
startup
-- 데이터베이스 중지
shutdown

/*산술/비교/논리 연산자
*/
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY+100 FROM HR.JOBS;

SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY+100 FROM HR.JOBS
WHERE MIN_SALARY != 6000;

-- 2007년 1월 1일 이후인 데이터를 출력하는 쿼리
SELECT EMPLOYEE_ID, START_DATE, END_DATE,JOB_ID,DEPARTMENT_ID FROM HR.JOB_HISTORY WHERE START_DATE >= '2007-01-01';


-- BETWEEN AND 연산자
-- 10,000 미만 30,000 초과인 데이터만 조회
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY FROM HR.JOBS WHERE MIN_SALARY NOT BETWEEN 10000 AND 30000;

-- IN
-- MIN_SALARY 컬럼에 2,500 , 5,500 값이 있는 데이터 조회
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY FROM HR.JOBS WHERE MIN_SALARY IN (2500,5500);


-- LIKE 연산자 
-- PU로 시작하는 JOB_ID 출력
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY FROM HR.JOBS WHERE JOB_ID LIKE 'PU%';

-- 이름의 두 번째 글자가 A인 사람을 찾는 쿼리문

SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY FROM HR.JOBS WHERE JOB_ID LIKE '_A%';

-- 컬럼에 _ 가 들어간 데이터만 출력 
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY FROM HR.JOBS WHERE JOB_ID LIKE '%\_%' ESCAPE '\';


/* NULL 연산자
*/

-- 실행 불가
SELECT ENAME, JOB, COMM FROM EMP WHERE COMM=NULL;

-- 실행 가능
SELECT ENAME, JOB, COMM FROM EMP WHERE COMM IS NULL;
SELECT ENAME, JOB, COMM FROM EMP WHERE COMM IS NOT NULL;


-- ORDER BY 절
SELECT * FROM HR.JOB_HISTORY ORDER BY START_DATE DESC; 

/* DISTINCT ,별칭 , 연결 연산자
 * 동일한 데이터 값들이 중복되어 출력되지 않도록 사용한다.
*/
SELECT DISTINCT MAX_SALARY FROM HR.JOBS;

-- Alias
SELECT JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY AS MAX FROM HR.JOBS;

-- 연결 연산자
SELECT JOB_ID || '_EAI' FROM HR.JOBS;
SELECT JOB_ID || '_EAI'|| JOB_TITLE  FROM HR.JOBS;


-- DUAL

SELECT 24*60 FROM DUAL;
SELECT SYSDATE FROM DUAL;

-- ABS (절대값)

SELECT -10,ABS(-10) FROM DUAL;

-- FLOOR (소수점 버림)

SELECT 34.5432, FLOOR(34.5432) FROM DUAL;

-- ROUND (특정 자릿수에서 반올림)

SELECT 34.5678, ROUND(34.5467) FROM DUAL;
SELECT 34.5678, ROUND(34.5467,2) FROM DUAL;

-- TRUNC

SELECT TRUNC(34.5765,2) FROM DUAL;
SELECT TRUNC(34.5765,-1) FROM DUAL;

-- MOD (나누기 연산 후 나머지를 결과로 되돌려 줌)

SELECT MOD(27,2),MOD(27,5) FROM DUAL;

/*
 * 문자 처리 함수
 * 
*/

-- UPPER
SELECT UPPER('welcome to epozen') FROM DUAL;

-- LOWER
SELECT LOWER('WELCOM to epozen') FROM DUAL;

-- INITCAP
SELECT INITCAP('WELCOME TO ORACLE') FROM DUAL;

-- LENGTH
SELECT LENGTH('Oracle') FROM DUAL;

-- LENGTHB (바이트 수를 알려주는 함수)
SELECT LENGTHB('ORACLE') FROM DUAL;

-- INSTR (특정 문자의 위치를 구하는 함수)
SELECT INSTR('WELECOM TO ORACLE', 'O')FROM DUAL;

-- SUBSTR
SELECT SUBSTR('Welecome to Oracle',0,7) FROM DUAL;
-- SUBSTR , 결합 연산자 예시
SELECT EMPLOYEE_ID, 22||SUBSTR(START_DATE,3,6) AS "년도" FROM HR.JOB_HISTORY;

SELECT EMPLOYEE_ID, START_DATE FROM HR.JOB_HISTORY WHERE SUBSTR(START_DATE,7,6) ='21';
SELECT EMPLOYEE_ID, START_DATE FROM HR.JOB_HISTORY WHERE START_DATE LIKE ('%21%');

-- LTRIM/RTRIM (공백 문자를 삭제)
SELECT LTRIM('        ORACLE') FROM DUAL;
SELECT RTRIM('ORACLE        ') FROM DUAL;

-- TRIM (특정 문자를 잘라내는 함수)
SELECT TRIM('a' FROM 'aaaaORACLEaaaaa') FROM DUAL;


/*
 * 날짜 함수
 * 
 * 날짜 - 날짜 : 두 날짜 사이의 기간을 계산한다.
 * 
 * */

SELECT SYSDATE FROM DUAL;

-- MONTHS_BETWEEN (두 날짜 사이의 개월수를 구하는 함수)
SELECT EMPLOYEE_ID, MONTHS_BETWEEN(END_DATE ,START_DATE) FROM HR.JOB_HISTORY;
SELECT EMPLOYEE_ID, TRUNC(MONTHS_BETWEEN(END_DATE ,START_DATE)) AS "근무 개월 수"  FROM HR.JOB_HISTORY;

-- ADD_MONTHS (특정 개월 수를 더한 날짜를 구하는 함수)
SELECT EMPLOYEE_ID, ADD_MONTHS(END_DATE,4)  FROM HR.JOB_HISTORY; 
SELECT EMPLOYEE_ID, TRUNC(MONTHS_BETWEEN(ADD_MONTHS(END_DATE,4)  ,ADD_MONTHS(START_DATE,5) )) AS "근무 개월 수"  FROM HR.JOB_HISTORY;

-- NEXT_DAY (해당 날짜부터 시작하여 명시된 요일을 만나면, 해당되는 날짜를 반환하는 함수)
SELECT SYSDATE,NEXT_DAY(SYSDATE,3)FROM DUAL; 

-- LAST_DAY (해당 달의 마지막 날짜를 반환하는 함수)
SELECT EMPLOYEE_ID,LAST_DAY(END_DATE)FROM HR.JOB_HISTORY;


/*
 * 형변환
 * 
 */

-- TO_CHAR (날짜형 혹은 숫자형을 문자형으로 변환)
SELECT TO_CHAR(END_DATE,'YYYY-MM-DD')FROM HR.JOB_HISTORY;
SELECT TO_CHAR(END_DATE,'YYYY/MM/DD DAY')FROM HR.JOB_HISTORY;
SELECT TO_CHAR(END_DATE,'YYYY/MM/DD,HH24:MM:SS')FROM HR.JOB_HISTORY;

-- L (지역별 통화 기호)
SELECT TO_CHAR(DEPARTMENT_ID,'L999,999') FROM HR.JOB_HISTORY;
SELECT TO_CHAR(DEPARTMENT_ID,'L000,000') FROM HR.JOB_HISTORY;

SELECT * FROM HR.JOB_HISTORY;
-- TO_DATE (문자형 -> 날짜형)
SELECT START_DATE,END_DATE FROM HR.JOB_HISTORY WHERE START_DATE = TO_DATE(20060324,'YYYYMMDD');

-- TO_NUMBER
SELECT TO_NUMBER('20,000','99,999')-TO_NUMBER('10,000','99,999') FROM DUAL;

/*
 * NVL 
 * 
 * NULL을 0 또는 다른 값으로 변환하기 위해서 사용하는 함수
 */
SELECT EMPLOYEE_ID	,FIRST_NAME	,LAST_NAME	,EMAIL	,PHONE_NUMBER	,HIRE_DATE	,JOB_ID	,SALARY	,NVL(COMMISSION_PCT,0)	,MANAGER_ID	,DEPARTMENT_ID FROM HR.EMPLOYEES;


/*
 * DECODE (여러가지 경우에 대해서 선택할 수 있도록 하는 기능을 제공한다. SWITCH CASE문과 같은 기능이다.)
 */
SELECT DECODE(DEPARTMENT_ID,90,'ONE',100,'TWO')FROM HR.EMPLOYEES;
SELECT DECODE(MANAGER_ID,100,'A',120,'DEFAULT') FROM HR.EMPLOYEES;


/* CASE (IF ELSE와 유사한 구조)
 * 
 * DECODE 함수는 조건이 일지(=비교 연산자)하는 경우에 대해서만 적용하지만 CASE 함수는 다양한 비교 연산자를 이용하여 조건 제시 및 범위 지정할 수 있다는 점이 이 둘의 차이점이다.
 * 
 */

SELECT * FROM HR.EMPLOYEES;

SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,NVL(DEPARTMENT_ID,1000) AS DEPARTMENT_ID,
CASE
	WHEN DEPARTMENT_ID <= 80 THEN 'O'
	WHEN DEPARTMENT_ID=90 THEN 'A' 
	WHEN DEPARTMENT_ID=100 THEN 'B' 
	WHEN DEPARTMENT_ID > 109 THEN 'C' 
	WHEN DEPARTMENT_ID = 1000 THEN 'KING'
	END AS H FROM HR.EMPLOYEES;


/*
 * ================================복수행 함수================================================================
 * 
 * 단일행 함수 : 14개의 행에 대해서 단일행 함수의 결과는 14개의 행으로 구해짐
 * 복수행 함수 : 14개의 행에 대해서 복수행 함수의 결과는 1개의 행으로 구해짐
 * 
 */

-- SUM
SELECT SUM(DEPARTMENT_ID) FROM HR.EMPLOYEES;
-- AVG
SELECT AVG(DEPARTMENT_ID) FROM HR.EMPLOYEES;
--MAX
SELECT MAX(DEPARTMENT_ID) FROM HR.EMPLOYEES;
--MIN
SELECT MIN(DEPARTMENT_ID) FROM HR.EMPLOYEES;

/*
 * Q. 만약 사원들의 최대 급여와 최대 급여를 받는 사원의 이름도 함께 구하려면 어떻게 해야할까?
 * SELECT EMPLOYEE_ID, MAX(DEPARTMENT_ID) FROM HR.EMPLOYEES;
 * -> 그룹 함수의 결과값은 하나인데, 그룹 함수를 적용하지 않은 단순 컬럼의 로우는 14개이기 때문에 산출되는 로우의 수가 달라 둘을 매치할 수 없다.
 */


/* COUNT 함수는 NULL 값에 대한 개수를 세지 않는다.
 * 중복된 로우까지 카운트한다. 제거하기 위해선 DISTINCT 함수 사용
 */
-- COUNT
SELECT COUNT(DEPARTMENT_ID) FROM HR.EMPLOYEES;
SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM HR.EMPLOYEES;


/*
 * GROUP BY
 *
 * 특정 컬럼을 기준으로 그룹화하여 테이블에 존재하는 행들을 그룹별로 구분하기 위해 사용한다.
 *  그룹 함수를 쓰되, 어떤 컬럼값을 기준으로 그룹 함수를 적용할지 기술해야 한다.
 *
 */

SELECT DEPARTMENT_ID FROM HR.EMPLOYEES GROUP BY DEPARTMENT_ID;
SELECT * FROM HR.EMPLOYEES;
-- 그룹함수 사용시 그룹함수를 적용하지 않은 단순 컬럼은 SELECT 절에 함께 사용할 수 없다 했는데 에러가 나지 않은 이유는 GROUP BY를 사용하면 매치가 가능하기 때문이다.
SELECT JOB_ID,AVG(SALARY) FROM HR.EMPLOYEES GROUP BY JOB_ID;

-- 그룹 함수를 쓴 것을 제외하고 나머지 컬럼은 GROUP BY 절로 묶어줘야 한다.
SELECT HIRE_DATE,JOB_ID,AVG(SALARY)  FROM HR.EMPLOYEES GROUP BY JOB_ID,HIRE_DATE;

-- 예) 소속 JOB_ID별  최대 급여와 최소 급여를 구하는 쿼리문
SELECT JOB_ID, MAX(SALARY),MIN(SALARY)FROM HR.EMPLOYEES GROUP BY JOB_ID;

-- 예) 소속 부서별 급여 총액과 평균 급여를 구하는 쿼리문
SELECT JOB_ID,SUM(SALARY),AVG(SALARY) FROM HR.EMPLOYEES e GROUP BY JOB_ID;

/*
 * HAVING 절
 * 
 * GROUP BY 절에 의해 생성된 결과 값 중 원하는 조건에 부합하는 자료만 보고자 할 때 사용한다. 
 * 
 * WHERE : 조건을 사용하여 결과를 제한 (단순 컬럼)
 * HAVING : 그룹의 결과를 제한 (그룹 함수)
 */

SELECT JOB_ID,AVG(SALARY),SUM(SALARY) FROM HR.EMPLOYEES GROUP BY JOB_ID HAVING AVG(SALARY) >= 10000;

-- 급여의 최대값과 최소값을 구하되, 최대 급여가 2900 이상인 부서만 출력하는 쿼리

SELECT JOB_ID, MAX(SALARY) AS MAX_SAL , MIN(SALARY) FROM HR.EMPLOYEES GROUP BY JOB_ID HAVING MAX(SALARY) >= 2900; 











